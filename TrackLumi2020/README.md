# 2020 track luminosity studies

This directory contains the scripts and results for the track luminosity studies I did in 2020, based on the original code developed in 2016.

## Luminosity using zero counting with tracks

The basic script for making the track luminosity is the same, `TrackLumiZeroCounting`. For these studies I have modified it so that it uses a cut of sigma < 2.0, to ensure that the contribution from accidentals is minimized, but otherwise it's basically the same as what we developed in 2016. See the documentation in `TrackLumiZC` for details on this script.

However, there are a number of improvements made. In particular, the scripts for plotting the track lumi data against the online luminometers have been significantly improved, so they can use data from `brilcalc` rather than having to go through the rather cumbersome process of pulling data from the CondDB. This greatly simplifies the procedure for running on the 2016 data, as follows:

* Run `make_fill.py` with two arguments: the fill number, and the Slink data file name. This will automatically invoke `brilcalc` to get the luminosity (in the correct format), using the current 2016 paper normtags for hfoc and pltzero (`hfoc16PaperV3` and `pltzero16PaperV2`, respectively). Then, it will run `TrackLumiZeroCounting` with the correct gain calibration, alignment, and track distributions for the 2016 data and save the resulting file. (Obviously, you can update this for other years as appropriate.)

* To plot the results from a single fill, use `PlotTrackLumiFill.C`. This script takes an argument (the fill number), so to run it within ROOT, use something like `.x PlotTrackLumiFill.C(5340)`. Or you can run it from the command line in batch mode (useful if you want to run multiple fills) with `root -b -q PlotTrackLumiFill.C\(5340\)`. This will make three separate plots:
  * `TrackLumiVsTime_5340_fix.png` will contain the luminosity as a function of time for the track lumi, alongside hfoc and pltzero for comparison. Note that the script automatically scales the track luminosity to match the hfoc luminosity.
  * `TrackLumiRatiosVsTime_5340_fix.png` will contain the ratios for track/HFOC and track/PLTZ as a function of time.
  * `TrackLumiRatiosVsSBIL_5340_fix.png` will contain the ratios, but as a function of SBIL instead. They are fitted with a linear fit to determine the resulting nonlinearity of the track measurement with respect to hfoc/pltzero.

  By default, the script will attempt to automatically detect and fix cases where the pixel data for one of the PLT channels drops out or is otherwise bad (hence the `_fix` in the file name). If you want to disable this automatic fixing (if it's not working well or if you just want to see how bad the results look without it), set `attemptChannelFix` to `false` at the top of the script. Also, `TrackLumiZeroCounting` attempts to automatically determine the number of filled bunches; however, sometimes this determination fails. To override the automatically determined value, set the fill and correct number of bunches in the `nbx` map. Finally, if you want to run this script on a different year than 2016, make sure to update `nPixelChannels` to match the number of channels written out by `TrackLumiZeroCounting` (you will also have to update `TrackLumiZeroCounting` to actually write out the correct channels as well).

  Note that when making linearity plots, the script will automatically ignore any ratios outside the range [0.95, 1.05] so that weird outliers don't mess up the fit. The channel dropout detection algorithm uses the ratios of each channel's track rate to the overall track rate, and will mark a channel as bad (and exclude it from the luminosity measurement for the rest of the fill) if that ratio changes by more than 10%.

* To plot the results for a series of fills and look at the long-term stability and linearity, use `StabilityLinearity.C`. This basically runs the same procedure as above and makes two plots:
  * `RatioVsTimeLongterm_fix.png` is the ratio over time for the lumisections from all fills together.
  * `LinearityVsFill_fix.png` is the fitted slope as a function of SBIL on a fill-by-fill basis.

  Like `PlotTrackLumiFill.C`, you can set `attemptChannelFix`, `nbx`, and `nPixelChannels` as above. In addition, by default, the script will calibrate the track luminosity to HFOC on a fill-by-fill basis, which gives better agreement but is arguably less realistic; to disable this, set `constScaleFactor` to a (positive) constant value instead of `-1`. (This will add `_const` to your stability plot name. Note that this has no effect on the linearity plot, since that always uses the per-fill scale factor.) Also, the overall list of fills should be set in `fills`.

These two scripts have a fair amount of duplicated code -- arguably they should be refactored, but for now this is the setup.

Finally, the results included in this directory are the results of this study for 2016. For this study, I included 10 fills, 4958, 5013, 5052, 5109, 5183, 5261, 5282, 5340, 5394, and 5451. These fills were chosen to cover the entire year, be reasonably long (and thus have a good range of luminosity values), and have no known PLT operational issues (although as you can see many of them are affected by dropouts in the pixel data which did not affect the fast-or luminosity). 5005, which was the 2016 mu-scan fill, is also included, although it turns out that the resolution of the track-counting luminosity is insufficient for this to be a particularly useful fill to look at. The plots include the plots from `PlotTrackLumiFill.C` for each fill (in both fixed and unfixed versions) and the overall plots from `StabilityLinearity.C` for these ten fills. Finally, also included are the log files from `TrackLumiZeroCounting` for each fill, since these can contain useful information about the channel dropouts detected by that script.

## VdM analysis using track luminosity

In 2016, the vdM scans were performed using a special high-rate trigger, making it feasible to try to do a vdM analysis with the track counting data. This requires a few extra pieces. (Note: these scripts still use the regular sigma < 5.0 cut to reject accidentals, to maximize statistics available, although in practice I don't think it makes much difference. This means that we can't use these results to directly calibrate the results from above, but it turns out that this isn't really practical anyway.) This analysis can also be done in 2017-18; although the high-rate trigger had a lower rate there, these have somewhat better data quality (see the discussion below).

The appropriate script to run first is `TrackLumiZeroCountingVdM`. This is a somewhat modified version of `TrackLumiZeroCounting` with some changes, such as lowering the threshold for a channel to be declared problematic to a level more appropriate for VdM luminosities. This takes the same four arguments as `TrackLumiZeroCounting`, but you should also give it a fifth argument, which defines the time stamps for the scan. The output will then be with one data point for each step (rather than for each 5 minutes as normal). This can be done by using `interface/scripts/extractVDMTimestamps.py` in the PLT online software on the appropriate csv file, which in turn can be found in `/brildata/vdm` on the BRIL online machines. This will give you a fill with all scans in the file, containing the time stamps and the separation values. Then, take this file, take out the particular scan you're interested in, strip out the separation column, and add a row at the top containing the total number of steps (normally 27). You can see examples in `VdMSteps_4954_AllScans.txt` and `VdMSteps_4954_X1.txt`, which are the files for all scans in fill 4954 and specifically the first X scan in fill 4954, respectively. The latter is the file that should be given as the timestamp file to `TrackLumiZeroCountingVdM`.

After running `TrackLumiZeroCountingVdM`, you can also run `TrackLumiZeroCountingBXVdM`. This works similarly, but produces a separate output file for every bunch crossing. However, it is somewhat simpler, since it omits the code for detecting problematic channels entirely, on the assumption that hopefully your vdM data is good, and if not, you're probably in trouble anyway, and the code for automatically determining which bunches are filled, since the bunch-by-bunch analysis doesn't actually care about this fact. This will produce a large number of files named `TrackLumiZCNNNN.txt`, where NNNN is the BX number; place these in a folder named something like `TrackLumi_4954_X1_BX/` so the plotting scripts can find it there.

Note that these two programs are currently configured for **2017** scans. If you want to run them on different years, you will need to change the list of functional channels as defined in the `outputChannels` variable. For `TrackLumiZeroCountingBXVdM`, the program will normally write output files for every BX for which it finds data; if you want to restrict to a subset of those bunches, specify the desired bunches in `selectedBX` and set `useSpecificBX` to `true`. For normal vdM fills this shouldn't be necessary, since only the triggered BXs are present anyway.

Once you have all the necessary output files, there are two scripts to plot the output. `PlotTrackRatesVdM.C` is good for a first look at the data: it will simply plot the rates of all tracks, good tracks, and bad tracks per scan step. To run it normally, provide three arguments: the name of the text file with the track lumi data, the desired name of the output plot, and the title for the output plot. If run with no arguments, then it will default to running on the two scans from fill 4954 that were analyzed. (Note that `PlotTrackRatesVdM.C` is currently configured for 2016 data; if you want to use it for other years, you will need to change the number of active channels at the top, as well as presumably the output filenames.)

The real analysis script is `PlotTrackLumiVdM.C`. This will read the data from a text file with the track lumi data, and also the file with the information on the separation at each step (which it expects to be named something like `VdMSteps_NNNN_AllScans.txt`, where NNNN is the fill number), and fit the resulting curve with a single Gaussian to extract the beam overlap width (CapSigma).

At the top of the script, you will need to configure it appropriately for the scan that you're running on, including the fill number, the scan pair within the fill, and the number of active pixel channels. For fills 4945, 4954, and 6016, the script also includes the known list of bunches, per-bunch beam intensity, and conversion from the channel number in the file to readout channel number; if you want to use a different fill, you will need to add some code to provide the list of bunches in `bunches`, the per-bunch beam intensity in `beam1Intensity` and `beam2Intensity`, and the readout channel number in `convertToReadoutChannel`. To get the per-bunch beam intensity, the helper script `getBeamIntensities.py` is included. Run it with a fill number as argument; the script contains some prefilled values for the time to sample and active bunches for known fills, but if it's not one of those known fills, you will need to add those to the script as well. It will then produce arrays that you can then put into `PlotTrackLumiVdM.C`. You will also need to change fill number and the number of active pixel channels at the top of the file.

`PlotTrackLumiVdM.C` supports four different modes of operation:
* If called with no arguments, or with an argument of 0, the script will simply plot the results for all bunches combined, averaged over all channels. This is the simplest plot but since it is fitting a curve to the sum over all bunches, the results are not very meaningful.
* If called with an argument of 1, the script will iterate over all bunches, producing a fit and a plot for each (using the channel-averaged data), and then use the resulting fitted beam overlap width, in conjunction with the beam intensities, to derive a visible cross section (SigmaVis) for each bunch. It then produces two summary plots, one of the fitted beam width per bunch and one of the visible cross section per bunch.
* If called with an argument of 2, the script will iterate over all channels (using the all-bunch data), producing a fit and plot for each as well as a summary of fitted width and visible cross section per channel, similar to the above.
* If called with an arugment of 3, the script will iterate over all channels for a single bunch (currently set to BX 81 in the code), and then produce a fit and plot for each and a summary plot per channel as above.
You can also use it to run on a single scan output file (similar to above) by providing the text file name, the output file name, the plot title to use, and (optionally) a channel number to select that specific channel (by default, the channel average value will be used).

The result files from this study are included here. I ran these studies on several scans in fill 4954 (the main CMS vdM scan in 2016), 4945 (the first CMS vdM attempt in 2016, which was dumped about 3/4 of the way through the vdM program), and 6016 (the main CMS vdM scan in 2017). The input and output files are as follows, where NNNN denotes the fill number and P the number of the scan pair.

* `VdMSteps_NNNN_AllScans.txt` are the files containing all scans and separation data for the fill, produced by `extractVDMTimestamps.py`.
* `VdMSteps_NNNN_XP.txt` is the specific timestamp file for the X scan of scan pair P (and similarly for Y).
* `TrackLumiZC_NNNN_XP.txt` contains the overall results (i.e. summed over all BX) for the X scan of scan pair P (and similarly for Y).
* `TrackLumi_NNNN_XP_BX/` is a directory containing the per-BX results for the X scan of scan pair P for the fill (and similarly for Y). Each text file is named `TrackLumiZCBBBB.txt`, where BBBB is the bunch crossing number.
* Finally, `VdMResults_NNNN` contains the final result plots: the track rate plots; the individual scan curve fits both overall, per-channel, per-BX, and per-channel for a single BX; and finally the summary plots of CapSigma and SigmaVis vs. channel or BX. (I didn't bother including the plots for all of the scans analyzed, as most of them are not particularly meaningful, as described below. The successful scan, fill 6016 scan pair 4, should have the full set of plots.)

In the end, all of the 2016 scans are affected by an issue which appears to be caused by FIFO full errors towards the beginning of the fill, causing the data from the TBMs to be attached to the wrong event. You can see the FIFO full errors in the plots of error rates vs. time in `ErrorRates*.png`. The strongest signal of this is that the vdM scan curves in the noncolliding bunches look very similar to those in the colliding bunches, although they should be nearly empty. This also results in very large variations in the extracted bunch-by-bunch values for SigmaVis. This also affects the first two 2017 scans considered. However, the final 2017 scan (scan pair 4) appears to be free of this issue, and produces results which have a consistent SigmaVis across bunches.
