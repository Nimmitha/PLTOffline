# 2020 track luminosity studies

This directory contains the scripts and results for the track luminosity studies I did in 2020, based on the original code developed in 2016.

## Luminosity using zero counting with tracks

The basic script for making the track luminosity is the same, `TrackLumiZeroCounting`. For these studies I have modified it so that it uses a cut of sigma < 2.0, to ensure that the contribution from accidentals is minimized, but otherwise it's basically the same as what we developed in 2016. See the documentation in `TrackLumiZC` for details on this script.

However, there are a number of improvements made. In particular, the scripts for plotting the track lumi data against the online luminometers have been significantly improved, so they can use data from `brilcalc` rather than having to go through the rather cumbersome process of pulling data from the CondDB. This greatly simplifies the procedure for running on the 2016 data, as follows:

* Run `make_fill.py` with two arguments: the fill number, and the Slink data file name. This will automatically invoke `brilcalc` to get the luminosity (in the correct format), using the current 2016 paper normtags for hfoc and pltzero (`hfoc16PaperV3` and `pltzero16PaperV2`, respectively). Then, it will run `TrackLumiZeroCounting` with the correct gain calibration, alignment, and track distributions for the 2016 data and save the resulting file. (Obviously, you can update this for other years as appropriate.)

* To plot the results from a single fill, use `PlotTrackLumiFill.C`. This script takes an argument (the fill number), so to run it within ROOT, use something like `.x PlotTrackLumiFill.C(5340)`. Or you can run it from the command line in batch mode (useful if you want to run multiple fills) with `root -b -q PlotTrackLumiFill.C\(5340\)`. This will make three separate plots:
  * `TrackLumiVsTime_5340_fix.png` will contain the luminosity as a function of time for the track lumi, alongside hfoc and pltzero for comparison. Note that the script automatically scales the track luminosity to match the hfoc luminosity.
  * `TrackLumiRatiosVsTime_5340_fix.png` will contain the ratios for track/HFOC and track/PLTZ as a function of time.
  * `TrackLumiRatiosVsSBIL_5340_fix.png` will contain the ratios, but as a function of SBIL instead. They are fitted with a linear fit to determine the resulting nonlinearity of the track measurement with respect to hfoc/pltzero.

  By default, the script will attempt to automatically detect and fix cases where the pixel data for one of the PLT channels drops out or is otherwise bad (hence the `_fix` in the file name). If you want to disable this automatic fixing (if it's not working well or if you just want to see how bad the results look without it), set `attemptChannelFix` to `false` at the top of the script. Also, `TrackLumiZeroCounting` attempts to automatically determine the number of filled bunches; however, sometimes this determination fails. To override the automatically determined value, set the fill and correct number of bunches in the `nbx` map. Finally, if you want to run this script on a different year than 2016, make sure to update `nPixelChannels` to match the number of channels written out by `TrackLumiZeroCounting` (you will also have to update `TrackLumiZeroCounting` to actually write out the correct channels as well).

  Note that when making linearity plots, the script will automatically ignore any ratios outside the range [0.95, 1.05] so that weird outliers don't mess up the fit. The channel dropout detection algorithm uses the ratios of each channel's track rate to the overall track rate, and will mark a channel as bad (and exclude it from the luminosity measurement for the rest of the fill) if that ratio changes by more than 10%.

* To plot the results for a series of fills and look at the long-term stability and linearity, use `StabilityLinearity.C`. This basically runs the same procedure as above and makes two plots:
  * `RatioVsTimeLongterm_fix.png` is the ratio over time for the lumisections from all fills together.
  * `LinearityVsFill_fix.png` is the fitted slope as a function of SBIL on a fill-by-fill basis.

  Like `PlotTrackLumiFill.C`, you can set `attemptChannelFix`, `nbx`, and `nPixelChannels` as above. In addition, by default, the script will calibrate the track luminosity to HFOC on a fill-by-fill basis, which gives better agreement but is arguably less realistic; to disable this, set `constScaleFactor` to a (positive) constant value instead of `-1`. (This will add `_const` to your stability plot name. Note that this has no effect on the linearity plot, since that always uses the per-fill scale factor.) Also, the overall list of fills should be set in `fills`.

These two scripts have a fair amount of duplicated code -- arguably they should be refactored, but for now this is the setup.

Finally, the results included in this directory are the results of this study for 2016. For this study, I included 10 fills, 4958, 5013, 5052, 5109, 5183, 5261, 5282, 5340, 5394, and 5451. These fills were chosen to cover the entire year, be reasonably long (and thus have a good range of luminosity values), and have no known PLT operational issues (although as you can see many of them are affected by dropouts in the pixel data which did not affect the fast-or luminosity). 5005, which was the 2016 mu-scan fill, is also included, although it turns out that the resolution of the track-counting luminosity is insufficient for this to be a particularly useful fill to look at. The plots include the plots from `PlotTrackLumiFill.C` for each fill (in both fixed and unfixed versions) and the overall plots from `StabilityLinearity.C` for these ten fills. Finally, also included are the log files from `TrackLumiZeroCounting` for each fill, since these can contain useful information about the channel dropouts detected by that script.

## VdM analysis using track luminosity

In 2016, the VdM scans were performed using a special high-rate trigger, making it feasible to try to do a VdM analysis with the track counting data. This requires a few extra pieces. (Note: these scripts still use the regular sigma < 5.0 cut to reject accidentals, to maximize statistics available, although in practice I don't think it makes much difference. This means that we can't use these results to directly calibrate the results from above, but it turns out that this isn't really practical anyway.)

The appropriate script to run first is `TrackLumiZeroCountingVdM`. This is a somewhat modified version of `TrackLumiZeroCounting` with some changes, such as lowering the threshold for a channel to be declared problematic to a level more appropriate for VdM luminosities. This takes the same four arguments as `TrackLumiZeroCounting`, but you should also give it a fifth argument, which defines the time stamps for the scan. The output will then be with one data point for each step (rather than for each 5 minutes as normal). This can be done by using `interface/scripts/extractVDMTimestamps.py` in the PLT online software on the appropriate csv file, which in turn can be found in `/brildata/vdm` on the BRIL online machines. This will give you a fill with all scans in the file, containing the time stamps and the separation values. Then, take this file, take out the particular scan you're interested in, strip out the separation column, and add a row at the top containing the total number of steps (normally 27). You can see examples in `VdMSteps_4954_AllScans.txt` and `VdMSteps_4954_X1.txt`, which are the files for all scans in fill 4954 and specifically the first X scan in fill 4954, respectively. The latter is the file that should be given as the timestamp file to `TrackLumiZeroCountingVdM`.

After running `TrackLumiZeroCountingVdM`, you can also run `TrackLumiZeroCountingBXVdM`. This works similarly, but produces a separate output file for every bunch crossing. However, it is somewhat simpler, since it omits the code for detecting problematic channels entirely, on the assumption that hopefully your VdM data is good, and if not, you're probably in trouble anyway, and the code for automatically determining which bunches are filled, since the bunch-by-bunch analysis doesn't actually care about this fact. (However, the trigger pattern is still hardcoded into the script, since the code will reject any events in BXes it's not expecting, so you'll need to update this for running on years other than 2016, or you could probably remove it entirely without any ill effects.) This will produce a large number of files named `TrackLumiZCNNNN.txt`, where NNNN is the BX number; place these in a folder named something like `TrackLumi_4954_X1_BX/` so the plotting scripts can find it there.

Once you have all the necessary output files, there are two scripts to plot the output. `PlotTrackRatesVdM.C` is good for a first look at the data: it will simply plot the rates of all tracks, good tracks, and bad tracks per scan step. To run it normally, provide three arguments: the name of the text file with the track lumi data, the desired name of the output plot, and the title for the output plot. If run with no arguments, then it will default to running on the two scans from fill 4954 that were analyzed.

The real analysis script is `PlotTrackLumiVdM.C`. This will read the data from a text file with the track lumi data, and also the file with the information on the separation at each step (which it expects to be named something like `VdMSteps_NNNN_AllScans.txt`, where NNNN is the fill number), and fit the resulting curve with a single Gaussian to extract the beam overlap width (CapSigma).

This is configured for 2016 fills; to use it for other fills, you will have to update the list of bunches and the per-bunch beam intensity at the appropriate place. To get the per-bunch beam intensity, the helper script `getBeamIntensities.py` is included. Just edit it to contain the target fill, time to sample, and bunches, and then run it to get arrays that you can then put into `PlotTrackLumiVdM.C`. You will also need to change fill number and the number of active pixel channels at the top of the file.

`PlotTrackLumiVdM.C` supports four different modes of operation:
* If called with no arguments, or with an argument of 0, the script will simply plot the results for all bunches combined, averaged over all channels. This is the simplest plot but since it is fitting a curve to the sum over all bunches, the results are not very meaningful.
* If called with an argument of 1, the script will iterate over all bunches, producing a fit and a plot for each (using the channel-averaged data), and then use the resulting fitted beam overlap width, in conjunction with the beam intensities, to derive a visible cross section (SigmaVis) for each bunch. It then produces two summary plots, one of the fitted beam width per bunch and one of the visible cross section per bunch.
* If called with an argument of 2, the script will iterate over all channels (using the all-bunch data), producing a fit and plot for each as well as a summary of fitted width and visible cross section per channel, similar to the above.
* If called with an arugment of 3, the script will iterate over all channels for a single bunch (currently set to BX 81 in the code), and then produce a fit and plot for each and a summary plot per channel as above.
You can also use it to run on a single scan output file (similar to above) by providing the text file name, the output file name, the plot title to use, and (optionally) a channel number to select that specific channel (by default, the channel average value will be used).

The result files from this study are included here. I ran on both fill 4954 (the main CMS VdM scan) and 4945 (the first CMS VdM attempt, which was dumped about 3/4 of the way through the VdM program). They are:
* `VdMSteps_4945_AllScans.txt` and `VdMSteps_4954_AllScans.txt` are the files containing all scans and separation data for the two VdM scans.
* `VdMSteps_4954_X1.txt` (and similarly for `4945` and `Y1`) are the specific timestamp files for the X1 and Y1 scans in the two fills.
* `TrackLumiZC_4954_X1.txt` (and similarly for `4945` and `Y1`) contains the overall results (i.e. summed over all BX) for the X1 and Y1 scans in the two fills.
* `TrackLumi_4954_X1_BX/` (and similarly for `4945` and `Y1`) contains the per-BX results for each scan for each fill (labeled by BX number).
* Finally, `VdMResults_4954` (and similarly for `4945`) contains the final result plots: the track rate plots; the individual scan curve fits both overall, per-channel, per-BX, and per-channel for a single BX; and finally the summary plots of CapSigma and SigmaVis vs. channel or BX.

In the end, while the individual VdM scan curves and the fitted CapSigmas look reasonable, there is significant variation in the extracted bunch-by-bunch values for SigmaVis, which appears to be driven by large variations in the peak rates between bunches. This appears to be some kind of problem in how the bunch data is assigned, since we can see that there are also significant rates (which in fact can also be fitted to obtain a reasonable beam width) even in the empty and noncolliding bunches, and this problem appears to be in the data itself, but we don't really understand what could cause this kind of behavior.
